---
title: "MAF files summary"
author: "UMCCR"
date: "`r format(Sys.time(), '%d %B, %Y')`"
params:
  maf_dir: 
  maf_files: 
  datasets: 
  out_dir: 
output:
  html_document:
    theme: readable
    toc: true
    toc_float: true
    code_folding: hide
  rmdformats::material:
    highlight: kate
---

Mutation data summary for dataset(s) **`r params$datasets `**

***
NOTE: this report summarises only non-synonymous variants with high/moderate variant consequences, including *frame shift deletions*, *frame shift deletions*, *splice site mutations*, *translation start site mutations*, *nonsense mutation*, *nonstop mutations*, *in-frame deletion*, *in-frame insertions* and *missense mutation*, and ignores silent variants.

[*High impact variant consequence*](http://asia.ensembl.org/Help/Glossary?id=535) -	the variant is assumed to have high (disruptive) impact in the protein, probably causing protein truncation, loss of function or triggering nonsense mediated decay.

[*Moderate impact variant consequence*](http://asia.ensembl.org/Help/Glossary?id=535) -	a non-disruptive variant that might change protein effectiveness.

***

```{r define_functions, comment=NA, message=FALSE, warning=FALSE}
##### Define functions

##### Create 'not in' operator
"%!in%" <- function(x,table) match(x,table, nomatch = 0) == 0

##### Prepare object to write into a file
prepare2write <- function (x) {
  
  x2write <- cbind(rownames(x), x)
  colnames(x2write) <- c("Gene",colnames(x))
  return(x2write)
}

##### Assign colours to different datasets. These colours will be used to distinguish tabs in generated excel summary spreadsheets
getDatasetsColours <- function(datasets) {
  
  ##### Predefined selection of colours for datasets
  datasets.colours <- c("dodgerblue","firebrick","lightslategrey","darkseagreen","orange","darkcyan","bisque", "coral2", "cadetblue3","red","blue","green")
  
  f.datasets <- factor(datasets)
  vec.datasets <- datasets.colours[1:length(levels(f.datasets))]
  datasets.colour <- rep(0,length(f.datasets))
  for(i in 1:length(f.datasets))
    datasets.colour[i] <- vec.datasets[ f.datasets[i]==levels(f.datasets)]
  
  return( list(vec.datasets, datasets.colour) )
}

###### Generate dataTable for each dataset with all mutation information for selected gene, as provided in MAF files
mut.details.datasets <- function(mafInfo, datasets, gene) {
  
  ##### Vector with datasets with no mutations reported in selected gene
  datasets.noMut <- NULL
  
  ##### Create a list for htmlwidgets
  widges.list <- htmltools::tagList()
  
  for ( i in 1:length(datasets) ) {
  
    mut.details.gene <- mafInfo[[datasets[i]]]@data[ mafInfo[[datasets[i]]]@data[, Hugo_Symbol] %in% gene, ]
    
    if ( nrow(mut.details.gene) != 0 ) {
      
      widges.list[[i]] <- DT::datatable( data = mut.details.gene, caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets[i])), filter = "top", options = list(pageLength = 5) )
      
    } else {
      datasets.noMut <- c(datasets.noMut, datasets[i])
    }
  }
  
  ##### Report datasets with no mutations reported in selected gene
  if ( length(datasets.noMut) != 0 ) {
    
    cat(paste("Note, gene", gene, "has no mutations reported in the following datasets:", paste(datasets.noMut, collapse = ", "), "\n\n\n\n", sep=" "))
  }
  
  ##### Print a list of htmlwidgets
  widges.list
}

###### Generate lollipop plot for each dataset for selected gene
lollipops.datasets <- function(mafInfo, datasets, gene) {
  
  ##### Create a list to store MAF info for individual datasets
  for ( dataset in datasets ) {
    
    cat(paste(dataset, "\n\n", sep=" "))
    
    ##### Check if the gene has any mutations in correspoding dataset
    if ( nrow(subsetMaf(maf = mafInfo[[dataset]], includeSyn = FALSE, genes = gene, 
        query = "Variant_Type != 'CNV'")) != 0 ) {
      
      ##### Drawing lollipop for the top 10 genes in each dataset
      ##### Check if the amino acid changes information is available in MAF provided files. The script expects column called "HGVSp_Short", which is produced with vcf2maf (https://github.com/mskcc/vcf2maf) when converting VCFs to MAFs (https://github.com/cBioPortal/cbioportal/issues/2996) and describes a mutation's amino acid change. The "aa_mutation" field used for annotation in ICGC samples is also acceptable. NOTE: other possibilities are: "Protein_Change", "AAChange""
      if ( "HGVSp_Short" %in% maftools::getFields(mafInfo[[dataset]]) ) {
        
        plot(lollipopPlot(maf = mafInfo[[dataset]], gene = gene, AACol = "HGVSp_Short",  labelPos = "all" , showMutationRate = TRUE, cBioPortal = TRUE, fn = paste0(mutationMapsDir, "/", paste(dataset, gene, sep="_"))), add=TRUE )

      } else if ( "aa_mutation" %in% maftools::getFields(mafInfo[[dataset]]) ) {
        
        plot( lollipopPlot(maf = mafInfo[[dataset]], gene = gene, AACol = "aa_mutation",  labelPos = "all" , showMutationRate = TRUE, cBioPortal = TRUE, fn = paste0(mutationMapsDir, "/", paste(dataset, gene, sep="_"))) )
      
      ##### ...otherwise leave a message
      } else {
        cat(paste("This section was skipped for dataset", dataset, "since the corresponding MAF does not contain field with amino acid changes details!\n\n\n\n", sep=" "))
      }
    } else {
      cat(paste("Gene", gene, "has no mutations reported in dataset", dataset, "\n\n\n\n", sep=" "))
    }
  }
}

##### Stop the maftools::tcgaCompare function from printing the summary table
tcgaCompare_mod <- function (maf, capture_size = NULL, cohortName = NULL, primarySite = FALSE, 
    col = c("gray70", "black"), medianCol = "red", fn = NULL, 
    width = 8, height = 5, fontSize = 10) 
{
    tcga.cohort = system.file("extdata", "tcga_cohort.txt.gz", 
        package = "maftools")
    if (Sys.info()[["sysname"]] == "Windows") {
        tcga.cohort.gz = gzfile(description = tcga.cohort, open = "r")
        tcga.cohort <- suppressWarnings(data.table(read.csv(file = tcga.cohort.gz, 
            header = TRUE, sep = "\t", stringsAsFactors = FALSE)))
        close(tcga.cohort.gz)
    }
    else {
        tcga.cohort = data.table::fread(input = paste("zcat <", 
            tcga.cohort), sep = "\t", stringsAsFactors = FALSE)
    }
    if (primarySite) {
        tcga.cohort = tcga.cohort[, .(Tumor_Sample_Barcode, total, 
            site)]
        colnames(tcga.cohort)[3] = "cohort"
    }
    else {
        tcga.cohort = tcga.cohort[, .(Tumor_Sample_Barcode, total, 
            cohort)]
    }
    maf.mutload = getSampleSummary(maf)[, .(Tumor_Sample_Barcode, 
        total)]
    if (is.null(cohortName)) {
        cohortName = "Input"
    }
    maf.mutload[, `:=`(cohort, cohortName)]
    tcga.cohort$total = as.numeric(as.character(tcga.cohort$total))
    maf.mutload$total = as.numeric(as.character(maf.mutload$total))
    if (!is.null(capture_size)) {
        maf.mutload[, `:=`(total, total/capture_size)]
        tcga.cohort[, `:=`(total, total/50)]
    }
    tcga.cohort = rbind(tcga.cohort, maf.mutload)
    tcga.cohort.med = tcga.cohort[, .(.N, median(total)), cohort][order(V2, 
        decreasing = TRUE)]
    tcga.cohort$cohort = factor(x = tcga.cohort$cohort, levels = tcga.cohort.med$cohort)
    colnames(tcga.cohort.med) = c("Cohort", "Cohort_Size", "Median_Mutations")
    tcga.cohort$TCGA = ifelse(test = tcga.cohort$cohort %in% 
        cohortName, yes = "Input", no = "TCGA")
    tcga.cohort.gg = ggplot(data = tcga.cohort, aes(x = cohort, 
        y = total, group = Tumor_Sample_Barcode, color = TCGA)) + 
        geom_point(position = position_jitter(width = 0.3), size = 0.2, 
            alpha = 0.8) + geom_point(data = tcga.cohort.med, 
        aes(y = Median_Mutations, x = Cohort), shape = 95, inherit.aes = FALSE, 
        color = medianCol, size = 6) + cowplot::theme_cowplot(font_size = fontSize, 
        line_size = 1) + cowplot::background_grid(major = "x") + 
        theme(axis.text.x = element_text(angle = 45, vjust = 1, 
            hjust = 1, face = "bold"), legend.position = "none", 
            axis.text.y = element_text(face = "bold", size = 10), 
            axis.title.y = element_text(face = "bold", size = 12)) + 
        scale_color_manual(values = rev(col))
    if (is.null(capture_size)) {
        tcga.cohort.gg = tcga.cohort.gg + scale_y_log10(breaks = c(0.01, 
            0.1, 1, 10, 100, 1000, 10000)) + ylab("log10 (Mutations per sample)")
    }
    else {
        tcga.cohort.gg = tcga.cohort.gg + expand_limits(y = c(0.01, 
            1000)) + scale_y_log10(breaks = c(0.01, 0.1, 1, 10, 
            100, 1000), labels = c(0.01, 0.1, 1, 10, 100, 1000)) + 
            ylab("log10 (Mutations per MB)")
    }
    if (!is.null(fn)) {
        cowplot::save_plot(filename = paste0(fn, ".pdf"), plot = tcga.cohort.gg, 
            base_height = height, base_width = width)
        write.table(tcga.cohort.med, file = paste0(fn, "_mutation_load.tsv"), 
            sep = "\t", quote = FALSE, row.names = FALSE)
    }
    #message("Summary..")
    #print(tcga.cohort.med)
    print(tcga.cohort.gg)
    return(tcga.cohort.gg)
}

##### Perfrom oncodrive analysis. Clusters variants based on their position to detect disease causing genes
oncodrive.mod <- function(mafInfo, dataset, AACol, gl) {

  ##### Check whether it's possible to run oncodrive analysis for given dataset by calculating cluster scores
  nonsyn.scores <- parse_prot(mafInfo, AACol = AACol, gl = gl, m = 5, calBg = FALSE, nBg = 100)
    
  if ( !is.null(nonsyn.scores) ) {
      
    ##### Cluster variants based on their position to detect disease causing genes
    sig = oncodrive(maf = mafInfo, AACol = AACol, minMut = 5, pvalMethod = 'zscore')
    
    oncodrive.plot <- plotOncodrive(res = sig, fdrCutOff = 0.05, useFraction = FALSE)
      
    return(list(sig, oncodrive.plot))
  }
}

##### Functon to calcluate cluster score (from https://rdrr.io/github/PoisonAlien/maftools/src/R/clusterScore.R). It's required in order check whether it's possible to run oncodrive analysis for given dataset
parse_prot <- function(dat, AACol, gl, m, calBg = FALSE, nBg){

  mafInfo <- dat
  dat <- mafInfo@data
  
  if(is.null(AACol)){
    pchange = c('HGVSp_Short', 'Protein_Change', 'AAChange')
    if(pchange[pchange %in% colnames(dat)] > 0){
      pchange = suppressWarnings(pchange[pchange %in% colnames(dat)][1])
      message(paste0("Assuming protein change information are stored under column ", pchange,". Use argument AACol to override if necessary."))
      colnames(dat)[which(colnames(dat) == pchange)] = 'AAChange'
    }else{
      message('Available fields:')
      print(colnames(dat))
      stop('AAChange field not found in MAF. Use argument AACol to manually specifiy field name containing protein changes.')
    }
  }else{
    colnames(dat)[which(colnames(dat) == AACol)] = 'AAChange'
  }

  all.prot.dat = dat[,.(Hugo_Symbol, Variant_Classification, AAChange)]
  all.prot.dat = all.prot.dat[Variant_Classification != 'Splice_Site']
  #parse AAchanges to get postion
  prot.spl = strsplit(x = as.character(all.prot.dat$AAChange), split = '.', fixed = TRUE)
  prot.conv = sapply(sapply(prot.spl, function(x) x[length(x)]), '[', 1)

  all.prot.dat[,conv := prot.conv]
  all.prot.dat = all.prot.dat[!conv == 'NULL']

  #If conversions are in HGVSp_long (default HGVSp) format, we will remove strings Ter followed by anything (e.g; p.Asn1986GlnfsTer13)
  pos = gsub(pattern = 'Ter.*', replacement = '',x = all.prot.dat$conv)

  #Following parsing takes care of most of HGVSp_short and HGVSp_long format
  pos = gsub(pattern = '[[:alpha:]]', replacement = '', x = pos)
  pos = gsub(pattern = '\\*$', replacement = '', x = pos) #Remove * if nonsense mutation ends with *
  pos = gsub(pattern = '^\\*', replacement = '', x = pos) #Remove * if nonsense mutation starts with *
  pos = gsub(pattern = '\\*.*', replacement = '', x = pos) #Remove * followed by position e.g, p.C229Lfs*18

  pos = suppressWarnings( as.numeric(sapply(strsplit(x = pos, split = '_', fixed = TRUE), '[', 1)) )
  all.prot.dat[,pos := pos]

  all.prot.dat = all.prot.dat[!is.na(pos)] #Remove NA's

  gene.sum = mafInfo@gene.summary
  gene.sum = merge(x = gene.sum, y = gl, by = 'Hugo_Symbol', all.x = TRUE)
  gene.sum = gene.sum[!is.na(aa.length)]

  num_mut_colIndex = which(colnames(gene.sum) == 'total')
  aalen_colIndex = which(colnames(gene.sum) == 'aa.length')

  #Get background threshold
  gene.sum$th = apply(gene.sum, 1, function(x) get_threshold(gene_muts = as.numeric(x[num_mut_colIndex]), gene_length = as.numeric(x[aalen_colIndex])))
  #use only genes with atleast 2 (or m ) mutations.
  gene.sum = gene.sum[total >= m]

  if(calBg){
    if(nrow(gene.sum) < nBg){
      #message("Not enough genes to build background. Using predefined values. (Mean = 0.279; SD = 0.13)")
      return(NULL)
    } else{
      syn.res = c()
      pb <- txtProgressBar(min = 0, max = nrow(gene.sum), style = 3) #progress bar

      for(i in 1:nrow(gene.sum)){
        prot.dat = all.prot.dat[Hugo_Symbol %in% gene.sum[i, Hugo_Symbol]]
        syn.res = rbind(syn.res, cluster_prot(prot.dat = prot.dat, gene = gene.sum[i, Hugo_Symbol], th = gene.sum[i, th], protLen = gene.sum[i,aa.length]))
        setTxtProgressBar(pb, i)
      }
      return(syn.res)
    }
  } else{
    nonsyn.res = c()
    #pb <- txtProgressBar(min = 0, max = nrow(gene.sum), style = 3) #progress bar

    for(i in 1:nrow(gene.sum)){
      hs = gene.sum[i, Hugo_Symbol]
      #print(hs)
      prot.dat = all.prot.dat[Hugo_Symbol %in% hs]
      nonsyn.res = rbind(nonsyn.res, cluster_prot(prot.dat = prot.dat, gene = hs, th = gene.sum[Hugo_Symbol %in% hs, th], protLen = gene.sum[Hugo_Symbol %in% hs, aa.length]))
      #setTxtProgressBar(pb, i)
    }
    return(nonsyn.res)
  }
}

###### Estimate threshhold based on binaomial distribution (from https://rdrr.io/github/PoisonAlien/maftools/src/R/clusterScore.R). Required for parse_prot function
get_threshold <- function(gene_muts, gene_length){
  th = which(unlist(lapply(X = 2:gene_muts, FUN = function(x) dbinom(x = x, size = gene_muts, prob = 1/gene_length) )) < 0.01)[1]
  return(th+1)
}

###### Clustering function (from https://rdrr.io/github/PoisonAlien/maftools/src/R/clusterScore.R). Required for parse_prot function
cluster_prot <- function(prot.dat, gene, th, protLen){

  mergeDist = 5 #hard coded inter event distance.
  #prot.dat = all.prot.dat[Hugo_Symbol == gene]

  #Summarise counts per position
  pos.counts = prot.dat[,.N,pos]
  pos.counts = pos.counts[order(pos)]

  #classify position as meaningful if its greater than background threshhold.
  pos.counts$cluster = ifelse(test = pos.counts$N >= th, yes = 'meaningful', no = 'nonMeaningful')

  #Just choose meaningful positions
  clust.tbl = pos.counts[cluster %in% 'meaningful']
  nonclust.tbl = pos.counts[cluster %in% 'nonMeaningful']

  if(nrow(clust.tbl) == 0){
    #message(paste('No meaningful positions found for', gene, sep=' '))
    return(NULL)
  }

  clust.tbl$distance = c(0,diff(clust.tbl$pos)) #calculate inter event distance.

  #If more than one meaningful positions are found within a 5 aa distance, join them to form a cluster.
  if(nrow(clust.tbl) > 1){

    #initialize variables.
    cstart = end = clust.tbl[1,pos]
    n = clust.tbl[1,N]
    cdf = c()
    cluster = 1

    #Go through entire table and update variables.
    for(i in 2:nrow(clust.tbl)){
      pos = clust.tbl[i,pos]

      d = clust.tbl[i,distance]

      if(d < mergeDist){
        end = pos
        n = n + clust.tbl[i,N]
      }else{
        tempdf = data.frame(cluster = paste('cluster', cluster, sep='_'), start = cstart, end = end ,N = n)
        cdf = rbind(cdf, tempdf)
        cstart = end = pos
        n = clust.tbl[i,N]
        cluster = cluster + 1
      }
    }
    cdf = rbind(cdf, data.frame(cluster = paste('cluster', cluster, sep='_'), start = cstart, end = end ,N = n))
  } else {
    cdf = data.frame(cluster = 'cluster_1', start = clust.tbl$pos, end = clust.tbl$pos ,N = clust.tbl$N)
  }

  #merge adjacent variants to clusters.
  for(i in 1:nrow(cdf)){
    tempcdf = cdf[i,]
    nonclust.tbl$startDist = nonclust.tbl$pos - tempcdf$start
    nonclust.tbl$endDist = nonclust.tbl$pos - tempcdf$end

    merge.adj.to.start = nonclust.tbl[startDist >= -5 & startDist <= 0]
    if(nrow(merge.adj.to.start) > 0){
      tempcdf$start = merge.adj.to.start[which(merge.adj.to.start$startDist == min(merge.adj.to.start$startDist)),pos]
      tempcdf$N = tempcdf$N + sum(merge.adj.to.start$N)
    }

    merge.adj.to.end = nonclust.tbl[endDist <= 5 & endDist >= 0]
    if(nrow(merge.adj.to.end) > 0){
      tempcdf$end = merge.adj.to.end[which(merge.adj.to.end$endDist == max(merge.adj.to.end$endDist)),pos]
      tempcdf$N = tempcdf$N + sum(merge.adj.to.end$N)
    }
    cdf[i,] = tempcdf
  }
  cdf$Hugo_Symbol = gene

  #Calcluate cluster score.

  total.muts = nrow(prot.dat) #total variants for this gene.
  clusterScores = c()

  for(i in 1:nrow(cdf)){
    temp.prot.dat = prot.dat[pos >= as.numeric(cdf$start[i]) & pos <= as.numeric(cdf$end[i])]
    temp.prot.dat.summary = temp.prot.dat[,.N, pos]
    temp.prot.dat.summary[,fraction:= N/total.muts]

    peak = temp.prot.dat.summary[N == max(N), pos]

    posVector = as.numeric(temp.prot.dat.summary[,pos])
    fractionMutVector = unlist(lapply(posVector, FUN = function(x) temp.prot.dat.summary[pos == x, fraction]))
    distanceVector = suppressWarnings(abs(posVector - peak))

    clusterScores = c(clusterScores,  sum( fractionMutVector / (sqrt(2)^ distanceVector)))

  }

  cdf$clusterScore = clusterScores

  gene.clust.res = data.frame(Hugo_Symbol = gene, clusters = nrow(cdf), muts_in_clusters = sum(cdf$N), clusterScores = sum(cdf$clusterScore), protLen = protLen)
  return(gene.clust.res)
}
```

```{r load_libraries, warning=FALSE}
suppressMessages(library(knitr))
suppressMessages(library(maftools))
suppressMessages(library(openxlsx))
suppressMessages(library(ggplot2))
suppressMessages(library(DT))
```

## Datasets

This report summarises and visualises mutation data in [Mutation Annotation Format](https://software.broadinstitute.org/software/igv/MutationAnnotationFormat) (MAF) files for the following dataset(s):

```{r datasets, comment = NA}
##### Present patient cohorts to be summarised
##### Split the string of MAF files and put them into a vector
mafFiles <- unlist(strsplit(params$maf_files, split=',', fixed=TRUE))
mafFiles <- paste(params$maf_dir, mafFiles, sep="/")

##### Split the string of datasets names and put them into a vector
datasets.list <- unlist(strsplit(params$datasets, split=',', fixed=TRUE))

datasets.df <- as.data.frame( cbind(datasets.list, unlist(strsplit(params$maf_files, split=',', fixed=TRUE))) )
names(datasets.df) <- c("Dataset", "MAF file")

DT::datatable( data = datasets.df, filter = "none", options = list(pageLength = length(mafFiles), sDom  = '<"top">lrt<"bottom">ip') )

cat("These MAF files are located in the following directory: ", params$maf_dir, "\n\n")
```

```{r load_data, comment = NA, message=FALSE, warning=FALSE}
##### Read MAF files and put associated info into a list
##### Create a list to store MAF info for individual datasets
mafInfo <- vector("list", length(mafFiles))
names(mafInfo) <- datasets.list

##### NOTE: maftools by default summarises only non-synonymous variants with high/moderate variant consequences and ignores silent variants (https://github.com/PoisonAlien/maftools/issues/63), which are stored in "maf.silent" slot of the class MAF object (mafInfo[[i]]@maf.silent)
for ( i in 1:length(mafFiles) ) {
  mafInfo[[i]] = maftools::read.maf(maf = mafFiles[i], verbose = FALSE)
}

##### Create directory for output files
outDir <- paste(params$maf_dir, params$out_dir, sep = "/")
if ( !file.exists(params$out_dir) ){

  dir.create(outDir, recursive=TRUE)
}
```

```{r silent_variants, comment = NA, message=FALSE, warning=FALSE}
##### Identify and record samples with no non-synonymous mutations
##### Prepare list to store all samples and samples with > 0 non-synonymous variants
MAF_samples <- vector("list", length(datasets.list))
names(MAF_samples) <- datasets.list
MAF_samples.silent.df <- NULL

##### Loop through MAF files
for ( i in 1:length(mafFiles) ) {
  
  ##### Identify samples with no non-synonymours variants according to corresponding MAF file
  MAF_samples[[i]]$all <- unlist(unique(mafInfo[[i]]@maf.silent[, "Tumor_Sample_Barcode"]))
  MAF_samples[[i]]$nonsyn <- unlist(maftools::getSampleSummary(mafInfo[[i]])[, "Tumor_Sample_Barcode"])
  MAF_samples[[i]]$silent <-  MAF_samples[[i]]$all[ MAF_samples[[i]]$all %!in% MAF_samples[[i]]$nonsyn  ]
  
  ##### Check if there thre are any samples with no non-synonymours variants. If so, add them to data frame
  if ( length(MAF_samples[[i]]$silent) > 0 ) {
    for ( sample in MAF_samples[[i]]$silent ) {
      
      MAF_samples.silent.df <- rbind( MAF_samples.silent.df, cbind( datasets.list[i], sample))
    }
  }
}

colnames(MAF_samples.silent.df) <- c("Dataset", "Sample")
```

## Summary tables {.tabset}

### Overall summary

Table(s) with basic information about each dataset, including *NCBI build*, *number fo samples* and *mutated genes*, *number of different mutation types*, as well as the *total number of mutations*, as reported in corresponding MAF file(s).

```{r overll_summary, warning=FALSE}
##### Write overall summary into a file
##### Assign different colour to individual datasets
datasets.colour <- getDatasetsColours(datasets.list)

##### Create a new workbook
wb <- createWorkbook("MAF_summary.xlsx")

##### Add worksheets, one for each dataset
for ( i in 1:length(mafFiles) ) {
  
    addWorksheet(wb, substring(datasets.list[i], 0, 31), tabColour = datasets.colour[[1]][i])
    writeData(wb, sheet = i, mafInfo[[i]]@summary)
}

saveWorkbook(wb, paste(outDir, "MAF_summary.xlsx", sep="/"), overwrite = TRUE)

##### Present a MAF file summary table in the html report
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  widges.list[[i]] <- DT::datatable( data = mafInfo[[i]]@summary, caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "none", options = list(pageLength = nrow(mafInfo[[i]]@summary), sDom  = '<"top">lrt<"bottom">ip') )
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

```{r maf_fields, warning=FALSE}
##### Additionally ceate an excel spreadsheet listing all fields (columns) in the individaul MAF files
##### Create a new workbook
wb <- createWorkbook("MAF_fields.xlsx")

##### Add worksheets, one for each dataset
for ( i in 1:length(mafFiles) ) {
  
    addWorksheet(wb, substring(datasets.list[i], 0, 31), tabColour = datasets.colour[[1]][i])
    writeData(wb, sheet = i, maftools::getFields(mafInfo[[i]]))
}

saveWorkbook(wb, paste(outDir, "MAF_fields.xlsx", sep="/"), overwrite = TRUE)
```

### Samples summary

Table(s) summarising samples in individual datasets. Each table contains per-sample information (rows) about *number of different types of mutations* (columns), as well as the *total number of mutations* reported in corresponding MAF file.

```{r sample_summary, comment = NA, warning=FALSE}
##### Write samples summary into a file
##### Create a new workbook
wb <- createWorkbook("MAF_sample_summary.xlsx")

##### Add worksheets, one for each dataset
for ( i in 1:length(mafFiles) ) {
  
    addWorksheet(wb, substring(datasets.list[i], 0, 31), tabColour = datasets.colour[[1]][i])
    writeData(wb, sheet = i, maftools::getSampleSummary(mafInfo[[i]]))
}

saveWorkbook(wb, paste(outDir, "MAF_sample_summary.xlsx", sep="/"), overwrite = TRUE)

##### Present a sample table in the html report
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  widges.list[[i]] <- DT::datatable( data = maftools::getSampleSummary(mafInfo[[i]]), caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", options = list(pageLength = 5) )
}

##### Print a list of htmlwidgets
widges.list

##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

##### Note samples with no non-synonymours variants according to corresponding MAF file
if ( nrow(MAF_samples.silent.df) > 0 ) {
  cat("The samples listed below will not be included in the summary tables above, nor will be included in the summary plots\n\n\n")
}

DT::datatable( data = MAF_samples.silent.df, caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong("Samples with no non-synonymours variants detected")), filter = "top", options = list(pageLength = 5) )

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

### Genes summary

Table(s) summarising mutated genes in individual datasets. Each table contains per-gene information (rows) about *number of different types of mutations* (columns), as well as the *total number of mutations* reported in corresponding MAF file. The last two columns contain the *number of samples with mutations/alterations* in the corresponding gene.

```{r gene_summary, warning=FALSE}
##### Write gene summary into a file
##### Create a new workbook
wb <- createWorkbook("MAF_gene_summary.xlsx")

##### Add worksheets, one for each dataset
for ( i in 1:length(mafFiles) ) {
  
    addWorksheet(wb, substring(datasets.list[i], 0, 31), tabColour = datasets.colour[[1]][i])
    writeData(wb, sheet = i, maftools::getGeneSummary(mafInfo[[i]]))
}

saveWorkbook(wb, paste(outDir, "MAF_gene_summary.xlsx", sep="/"), overwrite = TRUE)

##### Present a gene table in the html report
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  widges.list[[i]] <- DT::datatable(data = maftools::getGeneSummary(mafInfo[[i]]), caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", options = list(pageLength = 5) )
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```


## Summary plots {.tabset .tabset-fade}

### MAF summary

A per-MAF file summary including *frequency of various mutation/SNV types/classes* (top panel), the *number of variants in each sample* as a stacked bar-plot (bottom-left) and *variant types* as a box-plot (bottom-middle), as well as the *frequency of different mutation types* for the **30 most frequently mutated genes** (bottom-right). The horizontal dashed line in stacked bar-plot represents median number of variants across the dataset.

```{r maf_summary_plot, comment = NA, fig.width = 9, fig.height = 9}
###### Generate separate plot for each dataset
for ( i in 1:length(mafFiles) ) {

  cat(paste(datasets.list[i], "\n\n", sep=" "))
  
  ##### Plotting MAF summary
  par(mar=c(4,4,2,0.5), oma=c(1.5,2,2,1))
  maftools::plotmafSummary(maf = mafInfo[[i]], top = 30, rmOutlier = TRUE, addStat = 'median', dashboard = TRUE, titvRaw = FALSE)
  mtext("MAF summary", outer=TRUE,  cex=1, line=-0.5)
}
```

### Oncoplot

Oncoplot(s) illustrating different types of mutations observed across samples for the **30 most frequently mutated genes**. The side- and top bar-plots present the frequency of mutations in these genes and in individual samples, respectively.

```{r maf_oncoplot, comment = NA, fig.width = 9, fig.height = 8}
##### Changing colours (from RColorBrewer palette) for variant classifications
col = RColorBrewer::brewer.pal(n = 8, name = 'Paired')
names(col) = c('Frame_Shift_Del','Missense_Mutation', 'Nonsense_Mutation', 'Multi_Hit', 'Frame_Shift_Ins',
               'In_Frame_Ins', 'Splice_Site', 'In_Frame_Del')

###### Generate separate plot for each dataset
for ( i in 1:length(mafFiles) ) {

  cat(paste(datasets.list[i], "\n\n", sep=" "))

  ##### Drawing oncoplots for the top 10 genes in each dataset
  plot.new()
  par(mar=c(4,4,2,0.5), oma=c(1.5,2,2,1))
  maftools::oncoplot(maf = mafInfo[[i]], colors = col, top = 30, fontSize = 12)
}
```

### Driver genes detection

Cancer driver genes detection based on positional clustering using [oncodriveCLUST](http://bg.upf.edu/group/projects/oncodrive-clust.php) algorithm based on the fact that most of the variants in cancer causing genes are enriched at few specific loci (hot-spots). According to this concept mutations in these regions potentially change the function of these proteins in a manner that provides an adaptive advantage to cancer cells and consequently are positively selected during clonal evolution of tumours. This property can thus be used to nominate novel candidate driver genes, as described in the paper [OncodriveCLUST](https://www.ncbi.nlm.nih.gov/pubmed/23884480) by Tamborero *et al*.

The size of the points on the scatter-plot(s) is proportional to the number of clusters found in the gene. X-axis shows the number of variants observed in these clusters. Y-axis illustrates false discovery rate (FDR) values transformed into -log10. Labels indicate Gene name with the number of observed clusters.

```{r maf_oncodrive_analysis,  include=FALSE }
##### In this chunk the clusters variants are calculated, but the results are reported in the next chunk
##### Import protein info data provided within maftools package
gl <- data.table::fread(input = paste("zcat <", system.file("extdata", "prot_len.txt.gz", package = "maftools")), sep = "\t", stringsAsFactors = FALSE)

##### Create a list to store MAF info for individual datasets
oncodrive.res <- vector("list", length(mafFiles))
names(oncodrive.res) <- datasets.list

###### Generate separate plot for each dataset
for ( i in 1:length(mafFiles) ) {
  
  ##### Check if the amino acid changes information is available in MAF provided files. The script expects column called "HGVSp_Short", which is produced with vcf2maf (https://github.com/mskcc/vcf2maf) when converting VCFs to MAFs (https://github.com/cBioPortal/cbioportal/issues/2996) and describes a mutation's amino acid change. The "aa_mutation" field used for annotation in ICGC samples is also acceptable.
  if ( "HGVSp_Short" %in% maftools::getFields(mafInfo[[i]]) ) {
          
    oncodrive.res[[datasets.list[i]]] <- oncodrive.mod(mafInfo[[i]], datasets.list[i], AACol = "HGVSp_Short", gl) 

  } else if ( "aa_mutation" %in% maftools::getFields(mafInfo[[i]]) ) {
    
    oncodrive.res[[datasets.list[i]]] <- oncodrive.mod(mafInfo[[i]], datasets.list[i], AACol = "aa_mutation", gl)
    
  } else {
    cat(paste("This section was skipped for dataset", datasets.list[i], "since the corresponding MAF does not contain field with amino acid changes details!\n\n\n\n", sep=" "))
  }
}
```

```{r maf_oncodrive_results, comment=NA, warning=FALSE, fig.width = 9, fig.height = 4 }
##### Create a new workbook
wb <- createWorkbook("MAF_sample_oncodriveCLUST.xlsx")
sheetNo <- 0
  
##### Create a list for htmlwidgets
#widges.list <- htmltools::tagList()
  
##### Draw oncodrive plot for each dataset
###### Generate separate plot for each dataset
for ( i in 1:length(mafFiles) ) {
  
  cat(paste(datasets.list[i], "\n\n", sep=" "))
    
  if ( !is.null(oncodrive.res[[datasets.list[i]]]) ) {
      
      plot(oncodrive.res[[datasets.list[i]]][[2]])
      
      sheetNo <- sheetNo+1
      
      ##### Write results into a file
      addWorksheet(wb, substring(datasets.list[i], 0, 31), tabColour = datasets.colour[[1]][i])
      writeData(wb, sheet = sheetNo, oncodrive.res[[datasets.list[i]]][[1]])
  
      ##### Report results in dataTable
      #widges.list[[i]] <- DT::datatable( data = oncodrive.res[[datasets.list[i]]][[1]], caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", options = list(pageLength = 5))
    
  } else {
    cat(paste("It was not possible to calculate cluster scores for dataset", datasets.list[i], "\n\n\n\n", sep=" "))
  }
}

##### Print a list of htmlwidgets
#widges.list

##### Write results into a file
saveWorkbook(wb, paste(outDir, "MAF_oncodriveCLUST.xlsx", sep="/"), overwrite = TRUE)
```

### Transitions/transversions

Plots presenting the transitions and transversions distribution in individual dataset(s). In each panel, the box-plots show the *overall distribution* of the six different conversions (*C>A*, *C>G*, *C>T*, *T>C*, *T>A* and *T>G*)(top-left), and the transitions and transversions *frequency* (top-right). The stacked bar-plot (bottom) displays the *fraction* of the six different conversions in each sample.

```{r maf_TiTv_plot, comment = NA}
###### Generate separate plot for each dataset
###### Create empty list for TiTv info from each dataset
titv.info <- list()

for ( i in 1:length(mafFiles) ) {

  cat(paste(datasets.list[i], "\n\n", sep=" "))

  ##### Drawing distribution plots of the transitions and transversions
  titv.info[[datasets.list[i]]] <- maftools::titv(maf = mafInfo[[i]], plot = FALSE, useSyn = TRUE)

  maftools::plotTiTv(res = titv.info[[datasets.list[i]]])
  mtext("Transition and transversions distribution", outer=TRUE,  cex=1, line=-1.5)
}
```

```{r maf_TiTv_table}
##### Write per-sample transitions and transversions distribution into a file
##### Create a new workbook
wb <- createWorkbook("MAF_summary_titv.xlsx")

##### Add worksheets, three for each dataset
for ( i in 1:length(mafFiles) ) {
  
    addWorksheet(wb, substring(paste0(datasets.list[i], " (fraction)"), 0, 31), tabColour = datasets.colour[[1]][i])
    writeData(wb, sheet = i*3-2, titv.info[[datasets.list[i]]]$fraction.contribution)
    
    addWorksheet(wb, substring(paste0(datasets.list[i], " (count)"), 0, 31), tabColour = datasets.colour[[1]][i])
    writeData(wb, sheet = i*3-1, titv.info[[datasets.list[i]]]$raw.counts)
    
    addWorksheet(wb, substring(paste0(datasets.list[i], " (TiTv fractions)"), 0, 31), tabColour = datasets.colour[[1]][i])
    writeData(wb, sheet = i*3, titv.info[[datasets.list[i]]]$TiTv.fractions)
}

saveWorkbook(wb, paste(outDir, "MAF_summary_titv.xlsx", sep="/"), overwrite = TRUE)
```

### Cross-cancers comparison

Plot(s) illustrating the mutation load in investigated dataset(s) along with distribution of variants compiled from over 10,000 whole-exome sequencing samples across 33 [TCGA](https://cancergenome.nih.gov/) landmark cohorts. Every dot represents a sample whereas the red horizontal lines are the median numbers of mutations in the respective cancer types. The vertical axis (log scaled) shows the number of mutations per megabase whereas the different cancer types are ordered on the horizontal axis based on their median numbers of somatic mutations. This plot is similar to the one described in the paper [Signatures of mutational processes in human cancer](https://www.ncbi.nlm.nih.gov/pubmed/23945592) by Alexandrov *et al*.

```{r maf_tcga_cohorts, comment = NA, message=FALSE, warning=FALSE}
###### Generate separate plot for each dataset
for ( i in 1:length(mafFiles) ) {
  
  cat(paste(datasets.list[i], "\n\n", sep=" "))
  
  ##### Compare mutation load against TCGA cohorts
  tcgaCompare_mod(maf = mafInfo[[i]], cohortName = datasets.list[i], primarySite=TRUE)
}
```

## Mutation maps {.tabset .tabset-fade}

Lollipop plot(s) showing mutation spots on protein structure for the **30 most frequently mutated genes** across all datasets. Many oncogenes have a preferential sites which are mutated more often than any other locus. These spots are considered to be mutational hot-spots and lollipop plots can be used to display them along with rest of the mutations. Note, that for the MAF file does not contain field with amino acid changes details. The longest transcript is used if multiple transcripts are available.

```{r top_mutated_genes, comment = NA, message=FALSE, warning=FALSE}
##### Get the 30 most frequently mutated genes across all datasets
mutRate.top.datasets <- NULL

for ( i in 1:length(mafFiles) ) {
  
  genes.top <- maftools::getGeneSummary(mafInfo[[i]])[c(1:30), Hugo_Symbol]
  sampleSize <- as.numeric(mafInfo[[i]]@summary[ID %in% "Samples", summary])
  
  mutRate.top <- round(getGeneSummary(x = mafInfo[[i]])[ Hugo_Symbol %in% genes.top, MutatedSamples]/sampleSize * 100, digits = 2)
  names(mutRate.top) <- genes.top
  
  mutRate.top.datasets <- c( mutRate.top.datasets, mutRate.top)
}

mutRate.top.datasets <- sort(sort(mutRate.top.datasets, decreasing = TRUE)[unique(names(mutRate.top.datasets))], decreasing = TRUE)[c(1:30)]

##### Create directory for pdf files
mutationMapsDir <- paste0(normalizePath(outDir), "/", "MAF_mutation_maps")

if ( !file.exists(mutationMapsDir) ){
  dir.create(mutationMapsDir, recursive=TRUE)
}
```

### `r names(mutRate.top.datasets)[1]`

```{r lollipop_plot_1, comment = NA, message=FALSE, warning=FALSE, fig.width = 9, fig.height = 3}
###### Generate lollipop plot for each dataset for 1st top mutated gene
lollipops.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[1])
```

### `r names(mutRate.top.datasets)[2]`

```{r lollipop_plot_2, comment = NA, message=FALSE, warning=FALSE, fig.width = 9, fig.height = 3}
###### Generate lollipop plot for each dataset for 2nd top mutated gene
lollipops.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[2])
```

### `r names(mutRate.top.datasets)[3]`

```{r lollipop_plot_3, comment = NA, message=FALSE, warning=FALSE, fig.width = 9, fig.height = 3}
###### Generate lollipop plot for each dataset for 3rd top mutated gene
lollipops.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[3])
```

### `r names(mutRate.top.datasets)[4]`

```{r lollipop_plot_4, comment = NA, message=FALSE, warning=FALSE, fig.width = 9, fig.height = 3}
###### Generate lollipop plot for each dataset for 4th top mutated gene
lollipops.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[4])
```

### `r names(mutRate.top.datasets)[5]`

```{r lollipop_plot_5, comment = NA, message=FALSE, warning=FALSE, fig.width = 9, fig.height = 3}
###### Generate lollipop plot for each dataset for 5th top mutated gene
lollipops.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[5])
```

### `r names(mutRate.top.datasets)[6]`

```{r lollipop_plot_6, comment = NA, message=FALSE, warning=FALSE, fig.width = 9, fig.height = 3}
###### Generate lollipop plot for each dataset for 6th top mutated gene
lollipops.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[6])
```

### `r names(mutRate.top.datasets)[7]`

```{r lollipop_plot_7, comment = NA, message=FALSE, warning=FALSE, fig.width = 9, fig.height = 3}
###### Generate lollipop plot for each dataset for 7th top mutated gene
lollipops.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[7])
```

### `r names(mutRate.top.datasets)[8]`

```{r lollipop_plot_8, comment = NA, message=FALSE, warning=FALSE, fig.width = 9, fig.height = 3}
###### Generate lollipop plot for each dataset for 8th top mutated gene
lollipops.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[8])
```

### `r names(mutRate.top.datasets)[9]`

```{r lollipop_plot_9, comment = NA, message=FALSE, warning=FALSE, fig.width = 9, fig.height = 3}
###### Generate lollipop plot for each dataset for 9th top mutated gene
lollipops.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[9])
```

### `r names(mutRate.top.datasets)[10]`

```{r lollipop_plot_10, comment = NA, message=FALSE, warning=FALSE, fig.width = 9, fig.height = 3}
###### Generate lollipop plot for each dataset for 10th top mutated gene
lollipops.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[10])
```

### `r names(mutRate.top.datasets)[11]`

```{r lollipop_plot_11, comment = NA, message=FALSE, warning=FALSE, fig.width = 9, fig.height = 3}
###### Generate lollipop plot for each dataset for 11th top mutated gene
lollipops.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[11])
```

### `r names(mutRate.top.datasets)[12]`

```{r lollipop_plot_12, comment = NA, message=FALSE, warning=FALSE, fig.width = 9, fig.height = 3}
###### Generate lollipop plot for each dataset for 12th top mutated gene
lollipops.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[12])
```

### `r names(mutRate.top.datasets)[13]`

```{r lollipop_plot_13, comment = NA, message=FALSE, warning=FALSE, fig.width = 9, fig.height = 3}
###### Generate lollipop plot for each dataset for 13th top mutated gene
lollipops.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[13])
```

### `r names(mutRate.top.datasets)[14]`

```{r lollipop_plot_14, comment = NA, message=FALSE, warning=FALSE, fig.width = 9, fig.height = 3}
###### Generate lollipop plot for each dataset for 14th top mutated gene
lollipops.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[14])
```

### `r names(mutRate.top.datasets)[15]`

```{r lollipop_plot_15, comment = NA, message=FALSE, warning=FALSE, fig.width = 9, fig.height = 3}
###### Generate lollipop plot for each dataset for 15th top mutated gene
lollipops.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[15])
```

### `r names(mutRate.top.datasets)[16]`

```{r lollipop_plot_16, comment = NA, message=FALSE, warning=FALSE, fig.width = 9, fig.height = 3}
###### Generate lollipop plot for each dataset for 16th top mutated gene
lollipops.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[16])
```

### `r names(mutRate.top.datasets)[17]`

```{r lollipop_plot_17, comment = NA, message=FALSE, warning=FALSE, fig.width = 9, fig.height = 3}
###### Generate lollipop plot for each dataset for 17th top mutated gene
lollipops.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[17])
```

### `r names(mutRate.top.datasets)[18]`

```{r lollipop_plot_18, comment = NA, message=FALSE, warning=FALSE, fig.width = 9, fig.height = 3}
###### Generate lollipop plot for each dataset for 18th top mutated gene
lollipops.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[18])
```

### `r names(mutRate.top.datasets)[19]`

```{r lollipop_plot_19, comment = NA, message=FALSE, warning=FALSE, fig.width = 9, fig.height = 3}
###### Generate lollipop plot for each dataset for 19th top mutated gene
lollipops.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[19])
```

### `r names(mutRate.top.datasets)[20]`

```{r lollipop_plot_20, comment = NA, message=FALSE, warning=FALSE, fig.width = 9, fig.height = 3}
###### Generate lollipop plot for each dataset for 20th top mutated gene
lollipops.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[20])
```

### `r names(mutRate.top.datasets)[21]`

```{r lollipop_plot_21, comment = NA, message=FALSE, warning=FALSE, fig.width = 9, fig.height = 3}
###### Generate lollipop plot for each dataset for 21st top mutated gene
lollipops.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[21])
```

### `r names(mutRate.top.datasets)[22]`

```{r lollipop_plot_22, comment = NA, message=FALSE, warning=FALSE, fig.width = 9, fig.height = 3}
###### Generate lollipop plot for each dataset for 22nd top mutated gene
lollipops.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[22])
```

### `r names(mutRate.top.datasets)[23]`

```{r lollipop_plot_23, comment = NA, message=FALSE, warning=FALSE, fig.width = 9, fig.height = 3}
###### Generate lollipop plot for each dataset for 23rd top mutated gene
lollipops.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[23])
```

### `r names(mutRate.top.datasets)[24]`

```{r lollipop_plot_24, comment = NA, message=FALSE, warning=FALSE, fig.width = 9, fig.height = 3}
###### Generate lollipop plot for each dataset for 24th top mutated gene
lollipops.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[24])
```

### `r names(mutRate.top.datasets)[25]`

```{r lollipop_plot_25, comment = NA, message=FALSE, warning=FALSE, fig.width = 9, fig.height = 3}
###### Generate lollipop plot for each dataset for 25th top mutated gene
lollipops.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[25])
```

### `r names(mutRate.top.datasets)[26]`

```{r lollipop_plot_26, comment = NA, message=FALSE, warning=FALSE, fig.width = 9, fig.height = 3}
###### Generate lollipop plot for each dataset for 26th top mutated gene
lollipops.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[26])
```
### `r names(mutRate.top.datasets)[27]`

```{r lollipop_plot_27, comment = NA, message=FALSE, warning=FALSE, fig.width = 9, fig.height = 3}
###### Generate lollipop plot for each dataset for 27th top mutated gene
lollipops.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[27])
```

### `r names(mutRate.top.datasets)[28]`

```{r lollipop_plot_28, comment = NA, message=FALSE, warning=FALSE, fig.width = 9, fig.height = 3}
###### Generate lollipop plot for each dataset for 28th top mutated gene
lollipops.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[28])
```

### `r names(mutRate.top.datasets)[29]`

```{r lollipop_plot_29, comment = NA, message=FALSE, warning=FALSE, fig.width = 9, fig.height = 3}
###### Generate lollipop plot for each dataset for 29th top mutated gene
lollipops.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[29])
```

### `r names(mutRate.top.datasets)[30]`

```{r lollipop_plot_30, comment = NA, message=FALSE, warning=FALSE, fig.width = 9, fig.height = 3}
###### Generate lollipop plot for each dataset for 30th top mutated gene
lollipops.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[30])
```

## Mutation details {.tabset .tabset-fade}

Tables with detailed information, as as provided in corresponding MAF file(s), for the **30 most frequently mutated genes** across all datasets.

```{r details_mut_table}
##### Provide detiles information for each dataset for 1st top mutated gene
##### Create a new workbook
wb <- createWorkbook("MAF_top_mutations_details.xlsx")

##### Add worksheets, one for each dataset
for ( i in 1:length(mafFiles) ) {
  
  ##### Extract mutation details
  mut.details <- mafInfo[[i]]@data[ mafInfo[[i]]@data[, Hugo_Symbol] %in% names(mutRate.top.datasets), ]

  addWorksheet(wb, substring(datasets.list[i], 0, 31), tabColour = datasets.colour[[1]][i])
  writeData(wb, sheet = i, mut.details[ order(mut.details$Hugo_Symbol) , ])
}

saveWorkbook(wb, paste(outDir, "MAF_top_mutations_details.xlsx", sep="/"), overwrite = TRUE)
```

### `r names(mutRate.top.datasets)[1]`

```{r details_mut_1, comment = NA}
##### Provide detiles information for each dataset for 1st top mutated gene
mut.details.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[1])
##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

### `r names(mutRate.top.datasets)[2]`

```{r details_mut_2, comment = NA}
##### Provide detiles information for each dataset for 2nd top mutated gene
mut.details.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[2])
##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

### `r names(mutRate.top.datasets)[3]`

```{r details_mut_3, comment = NA}
##### Provide detiles information for each dataset for 3rd top mutated gene
mut.details.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[3])
##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

### `r names(mutRate.top.datasets)[4]`

```{r details_mut_4, comment = NA}
##### Provide detiles information for each dataset for 4th top mutated gene
mut.details.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[4])
##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

### `r names(mutRate.top.datasets)[5]`

```{r details_mut_5, comment = NA}
##### Provide detiles information for each dataset for 5th top mutated gene
mut.details.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[5])
##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

### `r names(mutRate.top.datasets)[6]`

```{r details_mut_6, comment = NA}
##### Provide detiles information for each dataset for 6th top mutated gene
mut.details.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[6])
##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

### `r names(mutRate.top.datasets)[7]`

```{r details_mut_7, comment = NA}
##### Provide detiles information for each dataset for 7th top mutated gene
mut.details.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[7])
##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

### `r names(mutRate.top.datasets)[8]`

```{r details_mut_8, comment = NA}
##### Provide detiles information for each dataset for 8th top mutated gene
mut.details.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[8])
##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

### `r names(mutRate.top.datasets)[9]`

```{r details_mut_9, comment = NA}
##### Provide detiles information for each dataset for 9th top mutated gene
mut.details.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[9])
##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

### `r names(mutRate.top.datasets)[10]`

```{r details_mut_10, comment = NA}
##### Provide detiles information for each dataset for 10th top mutated gene
mut.details.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[10])
##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

### `r names(mutRate.top.datasets)[11]`

```{r details_mut_11, comment = NA}
##### Provide detiles information for each dataset for 11th top mutated gene
mut.details.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[11])
##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

### `r names(mutRate.top.datasets)[12]`

```{r details_mut_12, comment = NA}
##### Provide detiles information for each dataset for 12th top mutated gene
mut.details.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[12])
##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

### `r names(mutRate.top.datasets)[13]`

```{r details_mut_13, comment = NA}
##### Provide detiles information for each dataset for 13th top mutated gene
mut.details.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[13])
##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

### `r names(mutRate.top.datasets)[14]`

```{r details_mut_14, comment = NA}
##### Provide detiles information for each dataset for 14th top mutated gene
mut.details.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[14])
##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

### `r names(mutRate.top.datasets)[15]`

```{r details_mut_15, comment = NA}
##### Provide detiles information for each dataset for 15th top mutated gene
mut.details.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[15])
##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

### `r names(mutRate.top.datasets)[16]`

```{r details_mut_16, comment = NA}
##### Provide detiles information for each dataset for 16th top mutated gene
mut.details.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[16])
##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

### `r names(mutRate.top.datasets)[17]`

```{r details_mut_17, comment = NA}
##### Provide detiles information for each dataset for 17th top mutated gene
mut.details.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[17])
##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

### `r names(mutRate.top.datasets)[18]`

```{r details_mut_18, comment = NA}
##### Provide detiles information for each dataset for 18th top mutated gene
mut.details.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[18])
##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

### `r names(mutRate.top.datasets)[19]`

```{r details_mut_19, comment = NA}
##### Provide detiles information for each dataset for 19th top mutated gene
mut.details.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[19])
##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

### `r names(mutRate.top.datasets)[20]`

```{r details_mut_20, comment = NA}
##### Provide detiles information for each dataset for 20th top mutated gene
mut.details.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[20])
##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

### `r names(mutRate.top.datasets)[21]`

```{r details_mut_21, comment = NA}
##### Provide detiles information for each dataset for 21st top mutated gene
mut.details.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[21])
##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

### `r names(mutRate.top.datasets)[22]`

```{r details_mut_22, comment = NA}
##### Provide detiles information for each dataset for 22nd top mutated gene
mut.details.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[22])
##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

### `r names(mutRate.top.datasets)[23]`

```{r details_mut_23, comment = NA}
##### Provide detiles information for each dataset for 23rd top mutated gene
mut.details.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[23])
##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

### `r names(mutRate.top.datasets)[24]`

```{r details_mut_24, comment = NA}
##### Provide detiles information for each dataset for 24th top mutated gene
mut.details.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[24])
##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

### `r names(mutRate.top.datasets)[25]`

```{r details_mut_25, comment = NA}
##### Provide detiles information for each dataset for 25th top mutated gene
mut.details.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[25])
##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

### `r names(mutRate.top.datasets)[26]`

```{r details_mut_26, comment = NA}
##### Provide detiles information for each dataset for 26th top mutated gene
mut.details.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[26])
##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

### `r names(mutRate.top.datasets)[27]`

```{r details_mut_27, comment = NA}
##### Provide detiles information for each dataset for 27th top mutated gene
mut.details.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[27])
##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

### `r names(mutRate.top.datasets)[28]`

```{r details_mut_28, comment = NA}
##### Provide detiles information for each dataset for 28th top mutated gene
mut.details.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[28])
##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

### `r names(mutRate.top.datasets)[29]`

```{r details_mut_29, comment = NA}
##### Provide detiles information for each dataset for 29th top mutated gene
mut.details.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[29])
##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

### `r names(mutRate.top.datasets)[30]`

```{r details_mut_30, comment = NA}
##### Provide detiles information for each dataset for 30th top mutated gene
mut.details.datasets(mafInfo, datasets.list, names(mutRate.top.datasets)[30])
##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

## Heatmaps {.tabset .tabset-fade}

### Samples

Interactive heatmap(s) with colours indicating low (blue) and high (yellow) number of *various mutations types* (columns) detected in corresponding *samples* (rows). Samples are ordered by the number of mutations to facilitate identification of individuals with extreme mutation burden. 

```{r sample_summary_heatmap, message = FALSE, warning=FALSE, fig.width = 6, fig.height = 9}
suppressMessages(library(plotly))
suppressMessages(library(heatmaply))

##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

##### Display samples summary in a form of interactive heatmap
for ( i in 1:length(mafFiles) ) {

  sampleSummary <- data.frame(maftools::getSampleSummary(mafInfo[[i]]))
  rownames(sampleSummary) <-sampleSummary[,"Tumor_Sample_Barcode"]
  sampleSummary <- subset(sampleSummary, select=-c(Tumor_Sample_Barcode, total))

  ##### Generate interactive heatmap
  p <- heatmaply(sampleSummary, main = datasets.list[i], Rowv=NULL, Colv=NULL, scale="none", dendrogram="none", trace="none", hide_colorbar = FALSE, fontsize_row = 8, label_names=c("Sample","Mutation_type","Count")) %>%
  layout(width  = 900, height = 420, margin = list(l=150, r=10, b=80, t=50, pad=2), titlefont = list(size=16), xaxis = list(tickfont=list(size=10)), yaxis = list(tickfont=list(size=10)))

  ##### Add plot to the list for htmlwidgets
  widges.list[[i]] <- as_widget(ggplotly(p))

   ##### Save the heatmap as html (PLOTLY)
  htmlwidgets::saveWidget(as_widget(p), paste0(outDir, "/MAF_sample_summary_heatmap_", datasets.list[i], ".html"), selfcontained = TRUE)

  ##### Plotly option
  #p <- plot_ly(x = colnames(sampleSummary), y = rownames(sampleSummary), z = as.matrix(sampleSummary), height = 600, type = "heatmap") %>%
  #layout(title = paste0("Samples summary: ", datasets.list[i]), autosize = TRUE, margin = list(l=150, r=10, b=100, t=100, pad=4), showlegend = TRUE)

  #widges.list[[i]] <- ggplotly(p)
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:heatmaply", unload=FALSE)
detach("package:plotly", unload=FALSE)

##### Print a list of htmlwidgets
widges.list
```

### Genes

Interactive heatmap(s) with colours indicating low (blue) and high (yellow) number of *various mutations types* (columns) detected in corresponding *genes* (rows). Genes are ordered by the number of reported mutations. The *total number of mutations* in individual genes, as well as the *number of samples with mutations* are also presented in the last three columns. Note, for transparency only the **top 50 mutated genes** are presented.

```{r gene_summary_heatmap, message = FALSE, warning=FALSE, fig.width = 6, fig.height = 8}
suppressMessages(library(plotly))
suppressMessages(library(heatmaply))

##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

##### Display genes summary in a form of interactive heatmap
for ( i in 1:length(mafFiles) ) {

  geneSummary <- data.frame(maftools::getGeneSummary(mafInfo[[i]])[1:50,])
  rownames(geneSummary) <-geneSummary[,"Hugo_Symbol"]
  geneSummary <- subset(geneSummary, select=-c(Hugo_Symbol))

  ##### Generate interactive heatmap
  p <- heatmaply(geneSummary, main = datasets.list[i], Rowv=NULL, Colv=NULL, scale="none", dendrogram="none", trace="none", hide_colorbar = FALSE, fontsize_row = 8, label_names=c("Gene","Mutation_type","Count")) %>%
  layout(width  = 900, height = 420, margin = list(l=150, r=10, b=80, t=50, pad=2), titlefont = list(size=16), xaxis = list(tickfont=list(size=10)), yaxis = list(tickfont=list(size=10)))
  
  ##### Add plot to the list for htmlwidgets
  widges.list[[i]] <- as_widget(ggplotly(p))

  ##### Save the heatmap as html (PLOTLY)
  htmlwidgets::saveWidget(as_widget(p), paste0(outDir, "/MAF_gene_summary_heatmap_", datasets.list[i], ".html"), selfcontained = TRUE)

  ##### Plotly option
  #p <- plot_ly(x = colnames(geneSummary), y = rownames(geneSummary), z = as.matrix(geneSummary), height = 600, type = "heatmap") %>%
  #layout(title = paste0("Genes summary: ", datasets.list[i]), autosize = TRUE, margin = list(l=150, r=10, b=100, t=100, pad=4), showlegend = TRUE)

  #widges.list[[i]] <- ggplotly(p)
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:heatmaply", unload=FALSE)
detach("package:plotly", unload=FALSE)

##### Print a list of htmlwidgets
widges.list
```

### Pair-wise comparisons

Interactive heatmap of *adjusted p-values* from *Fisher Exact* test performed for all possible pair-wise comprisons to find differentially mutated genes between queried datasets and to aid identification of global differences in mutation patterns in corresponding MAF files. The rows and columns represent genes and datasets, respectively, and heatmap colours indicate the *Fisher Exact* test *adjusted p-values*. The colour key is on the left-hand side. **Low *p-values*** (yellow) **indicate differentially mutated genes between corresponding datasets**. Genes are clustered to facilite the indetification possible differences between individaul datasets. Note, only overlap of mutated genes reported across all MAF files is presented. This section is available for multiple MAFs and will be skipped if only one MAF file is provided.

**NOTE**: This step is skipped for the moment as it is too computationally intensive.

```{r compare_mafs, message = FALSE, warning=FALSE, comment = NA, fig.width = 6, fig.height = 12, eval = FALSE, echo = FALSE}
##### Skip this section if only one MAF file is provided
if ( length(mafFiles) != 1 ) {
  
  suppressMessages(library(plotly))
  suppressMessages(library(heatmaply))
  
  #####  Create matrix of possible comparisons
  comb <- combn(levels(factor(datasets.list)), 2)
  
  #####  Get number of possible comparisons using the following formula:
  #
  # n!/((n-r)!(r!))
  #
  # n = the number of classes to compare
  # r = the number of elements for single comparison
  #
  ################################################################################
  
  combNo <- factorial(length(datasets.list))/(factorial(length(datasets.list)-2)*(factorial(2))) # n!/((n-r)!(r!))
  
  combNames <- NULL
  mafCompare.res <- vector("list", combNo)
  
  ##### Perform pair-wise datasets MAFs comparisons
  for (i in 1:combNo) {
  
    combNames[i] <- paste(comb[1,i], comb[2,i], sep=" vs ")
  
    mafCompare.res[[i]] <- maftools::mafCompare(m1 = mafInfo[[comb[1,i]]], m2 = mafInfo[[comb[2,i]]], m1Name = comb[1,i], m2Name = comb[2,i], minMut = 0)$results
  
    ##### Sort the data-frame by gene symbol
    mafCompare.res[[i]] <- mafCompare.res[[i]][order(mafCompare.res[[i]]$Hugo_Symbol)]
  
    rownames(mafCompare.res[[i]]) <- mafCompare.res[[i]]$Hugo_Symbol
  }
  
  ##### Extract the intersection of genes for the heatmap
  common_genes <-  Reduce(intersect, lapply(mafCompare.res, row.names))
  mafCompare.res.common <-  lapply(mafCompare.res, function(x) { x[row.names(x) %in% common_genes,] })
  
  ##### Extract adjusted p-values for each comparison, use genes names fow row names
  mafCompare.res.common.p <- do.call(cbind, lapply(mafCompare.res.common, function(x) x[, c("Hugo_Symbol", "adjPval")]))
  common_genes <- mafCompare.res.common.p$Hugo_Symbol
  mafCompare.res.common.p <- mafCompare.res.common.p[,-c("Hugo_Symbol")]
  mafCompare.res.common.p <- as.matrix(mafCompare.res.common.p)
  colnames(mafCompare.res.common.p) <- combNames
  rownames(mafCompare.res.common.p) <- common_genes
  
  ##### Cluster genes
  hr <- hclust(as.dist(dist(mafCompare.res.common.p, method="euclidean")), method="ward.D")
  
  ##### Generate interactive heatmap
  p <- heatmaply(mafCompare.res.common.p, Rowv=as.dendrogram(hr), Colv=NULL, viridis(n=256, alpha = 1, begin = 1, end = 0, option = "viridis"), scale="none", dendrogram="row", trace="none", hide_colorbar = FALSE, fontsize_row = 8, label_names=c("Gene","Comparison","P-value")) %>%
    layout(width  = 900, height = 900, margin = list(l=150, r=10, b=350, t=50, pad=2), titlefont = list(size=16), xaxis = list(tickfont=list(size=10)), yaxis = list(tickfont=list(size=10)))
  
  as_widget(ggplotly(p))
  p
  ##### Save the heatmap as html (PLOTLY)
  htmlwidgets::saveWidget(as_widget(p), paste0(outDir, "/MAF_pair-wise_comparisons_heatmap.html"), selfcontained = TRUE)

  ##### Detach plotly package. Otherwise it clashes with other graphics devices
  detach("package:heatmaply", unload=FALSE)
  detach("package:plotly", unload=FALSE)
  
} else {
  
  cat(paste("This section was skipped since MAF for only one dataset (", datasets.list[i], ") was provided.\n\n", sep=" "))
}
```

```{r maf_visualisation_pdf, comment=NA, message=FALSE, warning=FALSE}

###### Save plots into PDF files
###### Generate separate file with plots for each dataset
for ( i in 1:length(mafFiles) ) {

  pdf( file = paste(outDir, "/MAF_summary_", datasets.list[i], ".pdf", sep = "") )

  ##### Plotting MAF summary
  par(mar=c(4,4,2,0.5), oma=c(1.5,2,2,1))
  plotmafSummary(maf = mafInfo[[i]], rmOutlier = TRUE, addStat = 'median', dashboard = TRUE, titvRaw = FALSE)
  mtext("MAF summary", outer=TRUE,  cex=1, line=-0.5)

  ##### Drawing oncoplots for the top 10 genes in each dataset
  plot.new()
  par(mar=c(4,4,2,0.5), oma=c(1.5,2,2,1))
  oncoplot(maf = mafInfo[[i]], top = 10, fontSize = 12)
  
  ##### Drawing oncodrive plot for each dataset
  if ( !is.null(oncodrive.res[[datasets.list[i]]]) ) {
      
      plot(oncodrive.res[[datasets.list[i]]][[2]])
  }
  
  ##### Drawing distribution plots of the transitions and transversions
  titv.info = titv(maf = mafInfo[[i]], plot = FALSE, useSyn = TRUE)

  plotTiTv(res = titv.info)
  mtext("Transition and transversions distribution", outer=TRUE,  cex=1, line=-1.5)

  ##### Compare mutation load against TCGA cohorts
  tcgaCompare_mod(maf = mafInfo[[i]], cohortName = datasets.list[i], primarySite=TRUE)
  mtext("Mutation load in TCGA cohorts", outer=TRUE,  cex=1, line=-0.5)
}

##### Add extra lines to make sure that this section doesn't overlap with the next one
```

## Parameters

```{r params_info, comment = NA}
for ( i in 1:length(params) ) {

  cat(paste("Parameter: ", names(params)[i], "\nValue: ", paste(unlist(params[i]), collapse = ","), "\n\n", sep=""))
}
```

## Addendum

```{r sessioninfo}
devtools::session_info()
```
